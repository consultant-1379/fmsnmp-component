package com.ericsson.oss.mediation.translator.model;

import java.util.Date;
import java.util.StringTokenizer;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ericsson.oss.mediation.translator.model.alarm.handlers.OtherAlarmHandlers;

public class HandleOtherAlarmAttribute {
	/**
	 * to avoid PMD Warnings
	 */
	private HandleOtherAlarmAttribute(){
		
	}
	
	private static final Logger LOGGER = LoggerFactory
			.getLogger(HandleOtherAlarmAttribute.class);
	
	
	public static final String AXDSEV = ".1.3.6.1.4.1.193.14.1.1.3.2.2.3.1.6";

	// ESA-SNF,For Counting XML elements
	//public static ArrayList xmlEleList = new ArrayList();
	// ESA-SNF CONSTANTS

	public static final String alarmModelDescription = ".1.3.6.1.4.1.193.110.2.666.1.1.2.1.6";
	public static final String alarmActiveResourceId = ".1.3.6.1.4.1.193.110.2.666.1.2.2.1.10";

	public static final String alarmActiveDescription = ".1.3.6.1.4.1.193.110.2.666.1.2.2.1.11";

	public static final String ituAlarmEventTypeB = ".1.3.6.1.4.1.193.110.2.667.1.1.1.1.2";

	public static final String ituProbableCauseB = ".1.3.6.1.4.1.193.110.2.667.1.1.1.1.3";

	public static final String ituAlarmEventType = ".1.3.6.1.2.1.121.1.1.1.1.2";

	public static final String ituProbableCause = ".1.3.6.1.2.1.121.1.1.1.1.3";

	// MMC CONSTANTS

	public static String eventTime = "The time the event or alarm was sent: ";
	public static String filterDescript = "The name of the filter is : ";
	public static String rdbmsState = "The state of this server's access to this database is: ";
	public static String numOutofSpaceAccesses = "The number of times the server has been unable to obtain disk spece since startup is : ";
	public static String genericListenerState = "The current state of the Generic Listener is : ";
	public static String eventName = "The name of the event that occurred is ";
	public static String eventId = "The ID of the registration that generated this event occurrence is ";
	public static String eventService = "The name of the service being monitored by this event is ";
	public static String eventUser = "The name of the user who registered for this event is ";
	public static String eventAppId = "The Id of the Enterprise Manager console application through which this event was registered is ";
	public static String eventArgs = "The arguments that were passed to the script that detected the event are : ";
	public static String eventResults = "The results generated by the script that detected the event are : ";

	public static String merOpState = "Operational state of MER component is : ";
	public static String merAdminState = "Adminstrative state of MER component is : ";
	public static String repQSize = "Maximum number of MDRs waiting for transmission to storage is : ";
	public static String repQlevel = "Actual number of MDRs waiting for transmission to storage is : ";
	public static String radiusAccQLevel = "Actual Number of events in the queue is : ";
	public static String radiusAccQSize = "Maximum Number of events in the queue is : ";

	public static String mmsCmSystemOpState = "The Operational state of the system is : ";
	public static String mmsCmSystemAdState = "Adminstrative state of the system is : ";

	public static String alarmOBjClass = "The class of the network resources associated with the event or alarm: ";
	public static String alarmOBjInstance = "The instance (of a class) of the network resource associated with the event or alarm: ";

	public static String coldStart = "A coldStart trap signifies that the sending protocol entity is reinitializing itself such that the agent's configuration or the protocol entity implementation may be  altered.";
	public static String warmStart = "A warmStart trap signifies that the sending protocol entity is reinitializing itself such that neither the agent configuration nor the protocol entity implementation is altered.";
	public static String linkDown = "A linkDown trap signifies that the sending protocol entity recognizes a failure in one of the communication links represented in the agent's configuration.";
	public static String linkUp = "A linkUp trap signifies that the sending protocol entity recognizes that one of the communication links  represented in the agent's configuration has come up.";
	public static String authenticationFailure = "An authenticationFailure trap signifies that the sending protocol entity is the addressee of a protocol message that is not properly authenticated.";
	public static String egpNeighborLoss = "An egpNeighborLoss trap signifies that an EGP neighbor for whom the sending protocol entity was an EGP peer has been marked down and the peer relationship no longer obtains.";

	public static String IfAdminState = "The Adminstrative State of the Interface is: ";
	public static String IfOperState = "The operational State of the Interface is: ";

	// RAD CONSTANTS

	public static String TrapVarComp = "The Component that issued the Trap is ";
	public static String TrapVarSWName = "RADIUS Server Software Identity is ";
	public static String TrapVarThreadsAvail = "The number of threads available in the thread worker pool is ";
	public static String TrapVarBytesAvail = "The number of bytes available in the file system is ";
	public static String TrapVarPrivateDir = "The path to the private directory used by the RADIUS server is ";
	public static String TrapVarNumberOfOccurrences = "The dilution factor for the trap is ";
	public static String TrapVarSQLConnects = "The number of connection attempts to a SQL database is ";
	public static String TrapVarSQLDisconnects = "The number of disconnects from a SQL database is ";
	public static String TrapVarSQLTimeouts = "The number of timeouts encountered on SQL Database transactions is ";
	public static String TrapVarServiceDispatcherErrCode = "Error code returned in an attempt to start the RADIUS service on Windows NT is ";
	public static String TrapVarSetStatusErrCode = "Error Code returned from service control dispatcher is ";
	public static String TrapVarGetDiskFreeSpaceErrCode = "The error code returned in response GetDiskFreeSpaceEx is ";
	public static String TrapVarIniString = "The INI file setting is ";
	public static String TrapVarDbType = "The type of database is ";
	public static String TrapVarFailedSystemName = "The name of the remote system failing connectivity is ";
	public static String TrapVarUserName = "The name of the user is ";
	public static String TrapVarPersistStoreName = "The name of the persistent storage is ";
	public static String TrapVarDiagnosticMessage = "Possible root causes of the trap is ";
	public static String TrapVarIPAddrPoolName = "The name of the IP address pool is ";
	public static String TrapVarIPAddrAvail = "The number of addresses available in the IP address pool is ";

	
	// ESA-SNF:SNFTrapPDU
	public static EventNotification handleSNFTrapPDU(final EventNotification notif,
			final String Name, final String Value, final String ituAlarmEventTypeoid, final String fdn) {
		// Declaration and Initialization
		final StringBuffer str = new StringBuffer("");
		
		 String moi1 = "", moi2 = "", moi3 = "", moifinal = "", tempSP = "";
		
		if (Name.equalsIgnoreCase("alarmModelDescription")) {
			try {
				final String amodel = Value.toString();

				LOGGER.info("1.Alarm Model Description received from the Node : "
						+ amodel);

				tempSP = amodel;
				notif.setSpecificProblem(amodel);
				
				final String restOfIndex = alarmModelDescription;

				final StringTokenizer inTok = new StringTokenizer(restOfIndex, ".");

				// Get the count of characters in alarm name
				final int countAlName = Integer.parseInt(inTok.nextToken());

				// iterate for the characters of AlarmName
				final StringBuffer alarmNameBuf = new StringBuffer();

				for (int alnameIndex = 0; alnameIndex < countAlName; ++alnameIndex) {
					try {
						alarmNameBuf.append((char) (Integer.parseInt(inTok
								.nextToken())));
					} catch (Exception ex) {
						LOGGER.error("Exception :" + ex.getStackTrace());
					}
				}

				LOGGER.info("2.Alarm List Name is : " + alarmNameBuf);
				moi1 = alarmNameBuf.toString();

				// Alarm List Name is mapped to Problem Text
				str.append("\nAlarm List Name = " + alarmNameBuf.toString());

				String alarmModelIndex = "";

				// alarmModelIndex
				if (inTok.hasMoreTokens()) {
					alarmModelIndex = inTok.nextToken();
				}

				moi2 = alarmModelIndex;
				/**
				 * Taken care of of displaying the Error Code.
				 */
				LOGGER.info("3.Alarm Model Index is : " + alarmModelIndex);
				str.append("\nAlarm Error Code=" + moi2);

				String alarmModelState = "";
				// alarmModelState
				if (inTok.hasMoreTokens())
				{
					alarmModelState = inTok.nextToken();
				}
				LOGGER.info("4.Alarm Model State is : " + alarmModelState);
				str.append("\nAlarm Model State = " + alarmModelState);

			} catch (Exception aln) {

				LOGGER.info("Exception while processing Alarm List Name");
				return notif;
			}

		}

		// 5.Processing alarmActiveResourceID and Setting into External Event
		// Agent ID
		if (Name.equalsIgnoreCase("alarmActiveResourceId")) {
			final String aresource = Value.toString();
			LOGGER.info("5.alarmActiveResourceID : " + aresource);
			str.append("\nAlarm Active ID = " + aresource);

			// Setting it to External Event Agent ID
			if (!(aresource == "")) {
				// Setting OOR based on ActiveAlarmResourceOID from XML file
				if (OtherAlarmHandlers.getResourceOIDName(
						aresource.substring(1, aresource.length() - 2), fdn) != null
						&& OtherAlarmHandlers.getResourceOIDName(
								aresource.substring(1, aresource.length()), fdn) != null) {
					final String ManagedObjectInstance = "Component="
							+ OtherAlarmHandlers.getResourceOIDName(aresource.substring(1,
									aresource.length() - 2), fdn)
							+ ",Component="
							+ OtherAlarmHandlers.getResourceOIDName(
									aresource.substring(1, aresource.length()),
									fdn);
					notif.setManagedObjectInstance(ManagedObjectInstance);
				}
			} else {
				LOGGER.info("Alarm Active Resource ID is not received in the Trap PDU");
				// No External Event ID is set here
			}

			// Alarm Active Resource ID needs to mapped to MOI
			moi3 = aresource;

			// 6.Processing alarmActiveDateandTime
			LOGGER.info("6.Processing Alarm Date and time : ");
			try {
				final String restOfIndex = alarmActiveResourceId;
				// LOGGER.info("--- RestofIndex : "+restOfIndex);

				// remove the alarm name component
			final StringTokenizer inTok = new StringTokenizer(restOfIndex, ".");

				// Get the count of characters in alarm name
			final String stringOfCountAlname = inTok.nextToken();
				final int countAlName = Integer.parseInt(stringOfCountAlname);
				int charCount = stringOfCountAlname.length();
				// iterate for the characters of AlarmName
				for (int alnameIndex = 0; alnameIndex < countAlName; ++alnameIndex) {
					final String temp = inTok.nextToken();
					charCount = charCount + temp.length();
				}

				// Get the date component
				final StringBuffer aldateBuf = new StringBuffer();

				final int countDate = Integer.parseInt(inTok.nextToken());

				// Get the 11 Octet OID
				int octetDigitsCount = 2;
				if (countDate > 10)
				{
					octetDigitsCount++;
				}
				final String dateStringExtracted = restOfIndex.substring(charCount
						+ countAlName + 1);
				LOGGER.info("Date string extracted is " + dateStringExtracted);
				final int sourceIndex = dateStringExtracted.indexOf("." + countDate
						+ ".") + 1;
				final int destinationIndex = dateStringExtracted.lastIndexOf(".");
				final String octet11OID = dateStringExtracted.substring(sourceIndex
						+ octetDigitsCount, destinationIndex);

				for (int alDateCount = 0; alDateCount < countDate; ++alDateCount) {
					aldateBuf
							.append((char) Integer.parseInt(inTok.nextToken()));
				}

				final String octet28DateTime = aldateBuf.toString();
				LOGGER.info("octet28DateTime:" + octet28DateTime);

				// get the activeindexComponent
				String alactIndex = "";
				if (inTok.hasMoreTokens()) {
					alactIndex = inTok.nextToken();
				}

				String actvid = "";

				try {

					if (countDate == 28) {
						// LOGGER.info("--- Setting 28 Octets Date & Time Format ");
					final Date octet28Date = HandleTimeTranslation
								.createAlarmDateAndTime(octet28DateTime,
										countDate);
						notif.setTime(octet28Date);
						notif.setTimeZone("UTC");
					}

					else if (countDate == 11) {
						LOGGER.info("--- Setting 11  Date & Time Format ");
						final Date octet11Date = HandleTimeTranslation
								.createAlarmDateAndTime(octet11OID);
						LOGGER.info("--- Date from 11 octet input :"
								+ HandleTimeTranslation
										.createAlarmDateAndTime(octet11OID));

						notif.setTime(octet11Date);
						notif.setTimeZone(HandleTimeTranslation
								.getTimeZone(octet11OID));
					}

					else {
						LOGGER.info("--- Setting Current Date & Time Format ");
						notif.setTime((HandleTimeTranslation.getCurrentTime()));
					}
				} catch (Exception ae) {
					LOGGER.info("ESATranslator::Date Format Exception: "
							+ aldateBuf.toString());
					LOGGER.info("ESATranslator::setTime(): "
							+ HandleTimeTranslation.getCurrentTime());
					// Exception thrown while processing Alarm Active Date and
					// Time
					// Hence setting the Local Current Time
					notif.setTime(HandleTimeTranslation.getCurrentTime());
					return notif;
				}

				// 7.Processing alarmActiveIndex
				// LOGGER.info("Processing alarmActiveIndex ");
				actvid = alactIndex;
				LOGGER.info("7.Alarm Active Index is : " + actvid);
				str.append("\nAlarm Active Index = " + actvid);

			} catch (Exception ex) {
				LOGGER.info("Exception while processing Alarm Active Date and Time");
				// Exception thrown while processing this VARBIND
				// Setting Date to local current Time
				notif.setTime(HandleTimeTranslation.getCurrentTime());
				LOGGER.info("Exception while processing Alarm Active Index and hence not setting the value in ALV");
				return notif;

			}

		}

		// 8.Processing Alarm Active Description and setting it to Problem Text
		// in ALV
		if (Name.equalsIgnoreCase("alarmActiveDescription")) {
			str.append("\nAlarm Active Description = " + Value.toString());
			LOGGER.info("8.Alarm Active Description from SNF is : "
					+ Value.toString());
		}

		// 9.Processing Alarm Event Type - VARBIND
		if (Name.equalsIgnoreCase("ituAlarmEventType"))
		{
			notif.setEventType(HandleEventType.getituAlarmEventType(Value));// Unknown
		}
		// 10.Processing ituPerceivedSeverity.
		// This block is used to Tokenize ituAlarmEventType and find the Alarm
		// Perceived Severity
		try {

			final String severity = ituAlarmEventTypeoid.toString().substring(
					ituAlarmEventTypeoid.toString().lastIndexOf(".") + 1);

			/************************
			 * //Processing PerceivedSeverity StringTokenizer st3 = new
			 * StringTokenizer(oid2.trim(),"."); String severity=""; int
			 * count=st3.countTokens();
			 * LOGGER.info("Count of values from the ituAlarmEventType OID :"+
			 * count); //Looping is performed here to fetch the Severity value,
			 * which falls in the End of this Varbind for (int m=0;m<count;m++)
			 * { severity =st3.nextToken().trim(); }
			 ***************************/

			LOGGER.info("10.Severity found in the Trap PDU is : " + severity);

			// Variable Severity hold the value of severity to be set for the
			// Alarm
			// The following code is used to map the Severity as per the M3100
			// and X733 Standards
			switch (Integer.parseInt(severity)) {
			case 1:
				notif.setSeverity(Constants.SEV_CLEARED);
				break;
			case 2:
				notif.setSeverity(Constants.SEV_INDETERMINATE);
				break;
			case 3:
				notif.setSeverity(Constants.SEV_CRITICAL);
				break;
			case 4:
				notif.setSeverity(Constants.SEV_MAJOR);
				break;
			case 5:
				notif.setSeverity(Constants.SEV_MINOR);
				break;
			case 6:
				notif.setSeverity(Constants.SEV_WARNING);
				break;
			default:
				notif.setSeverity(Constants.SEV_INDETERMINATE);
				break;
			}
		} catch (Exception exc) {
			LOGGER.info("10.ERROR IN PROCESSING");

			notif.setSeverity(Constants.SEV_INDETERMINATE);
			return notif;
		}

		moifinal = moi3 + "," + moi1 + "," + moi2;

		// 11.Processing Alarm Probable Cause - VARBIND
		if (Name.equalsIgnoreCase("ituProbableCause")
				|| Name.equalsIgnoreCase(ituProbableCauseB)) {
			try {
				int probableCause = 0;
				probableCause = Integer.parseInt(Value.toString());
				LOGGER.info("11.Probable Cause found in the SNF Trap PDU : "+ probableCause);
				final String probCause=String.valueOf(probableCause);
				
				notif.setProbableCause(probCause+ moifinal);
			} catch (Exception x) {
				LOGGER.info("11.ERROR IN PROCESSING");
				LOGGER.info("Exception while processing Probable Cause...setting Default PC for the SNF Trap");
				notif.setProbableCause("0"); // Indeterminate
				return notif;
			}
		}
		return notif;
	}


}
